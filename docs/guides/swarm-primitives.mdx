---
title: "Swarm Primitives"
description: "Build powerful multi-agent swarms using Agent Relay's flexible communication primitives"
---

Agent Relay provides the foundational primitives that enable any swarm orchestration pattern. Unlike frameworks that impose specific architectures, Agent Relay gives you complete flexibility to design your own multi-agent systems.

## Why Primitives Over Frameworks?

| Framework | Approach | Limitation |
|-----------|----------|------------|
| OpenAI Agents | Handoff-based routing | Prescriptive flow control |
| Swarms.ai | Pre-built swarm types | Configuration-heavy |
| Strands | Self-organizing swarms | AWS ecosystem lock-in |
| **Agent Relay** | **Communication primitives** | **You design the orchestration** |

## Primitives to Capabilities Mapping

Every swarm framework needs certain capabilities. Here's how Agent Relay primitives map to them:

| Capability | What It Enables | Agent Relay Primitive |
|------------|-----------------|----------------------|
| **Handoffs** | Transfer tasks between agents | `sendMessage()` with context |
| **Continuity** | Maintain state across disconnections | Session resume + `getInbox()` |
| **Consensus** | Group decision-making | `createProposal()` / `vote()` |
| **Memory** | Shared state across agents | Channels + state payloads |
| **Discovery** | Find available workers | `listAgents()` |
| **Monitoring** | Health checks, auto-scaling | `getMetrics()` / `getHealth()` |
| **Spawning** | Dynamic team composition | `spawn()` / `release()` |

---

## 1. Handoffs (Task Transfer)

Transfer work between agents with full context.

```typescript
// Direct handoff with context
sourceAgent.sendMessage(targetAgent, task, 'action', {
  handoff: true,
  context: { completedSteps: ['step1', 'step2'], state: myState },
  originalRequester: 'User',
});

// Target receives and continues
targetAgent.onMessage = (from, { body, data }) => {
  if (data?.handoff) {
    // Continue the task with transferred context
    processTask(body, data.context);
  }
};
```

### Handoff Patterns

<Tabs>
  <Tab title="Explicit Routing">
    Route to specialists based on task content:

    ```typescript
    function routeToSpecialist(task: string, context: any) {
      const specialist = determineSpecialist(task);
      coordinator.sendMessage(specialist, task, 'action', { context });
    }
    ```
  </Tab>

  <Tab title="Chain Handoff">
    Pass work through a sequence of agents:

    ```typescript
    agentA.sendMessage('AgentB', result, 'action', {
      chain: ['AgentC', 'AgentD'], // remaining chain
      accumulated: { stepA: result },
    });
    ```
  </Tab>

  <Tab title="Escalation">
    Escalate complex issues to supervisors:

    ```typescript
    if (needsEscalation(result)) {
      worker.sendMessage('Supervisor', task, 'action', {
        escalation: true,
        reason: 'Complexity exceeded threshold',
      });
    }
    ```
  </Tab>
</Tabs>

---

## 2. Continuity (Session Persistence)

Maintain state across disconnections and handoffs.

```typescript
// Session resume - automatic on reconnect
const client = new RelayClient({
  agentName: 'Worker',
  reconnect: true, // Resumes session automatically
});

// Inbox - messages stored when offline
const missed = await client.getInbox({ unreadOnly: true });

// State payloads - share state in messages
client.sendMessage(target, summary, 'state', {
  currentStep: 3,
  completedTasks: ['a', 'b'],
  sharedContext: { key: 'value' },
});
```

### Checkpoint Pattern

Save progress at each step for recovery:

```typescript
async function processWithCheckpoints(task: string) {
  const checkpoints: any[] = [];

  for (const step of steps) {
    const result = await executeStep(step);
    checkpoints.push({ step, result, timestamp: Date.now() });

    // Save checkpoint as state message
    client.sendMessage('StateStore', JSON.stringify(checkpoints), 'state');
  }
}

// Recovery from inbox
async function recoverState() {
  const stateMessages = await client.getInbox({ from: 'StateStore' });
  if (stateMessages.length > 0) {
    const latest = stateMessages[stateMessages.length - 1];
    return JSON.parse(latest.body);
  }
  return null; // Fresh start
}
```

---

## 3. Consensus (Group Decisions)

Native distributed decision-making without external dependencies.

```typescript
// Create a proposal
client.createProposal({
  title: 'Architecture Decision',
  description: 'Should we use microservices or monolith?',
  participants: ['Architect', 'DevLead', 'DevOps'],
  consensusType: 'supermajority', // majority | supermajority | unanimous | weighted | quorum
  threshold: 0.67,
  timeoutMs: 300000,
});

// Vote
client.vote({
  proposalId: 'prop_123',
  value: 'approve', // approve | reject | abstain
  reason: 'Microservices align with our scaling needs',
});
```

### Consensus Types

| Type | Description | Use Case |
|------|-------------|----------|
| `majority` | >50% agreement | General decisions |
| `supermajority` | >=threshold (default 2/3) | Important changes |
| `unanimous` | 100% agreement | Critical decisions |
| `weighted` | Votes weighted by role | Expert opinions matter more |
| `quorum` | Minimum participation + majority | Ensure enough voters |

### Use Cases

<CardGroup cols={3}>
  <Card title="Code Review" icon="code">
    Require N approvals before merge
  </Card>
  <Card title="Deployment Gates" icon="rocket">
    Unanimous approval for production
  </Card>
  <Card title="API Design" icon="diagram-project">
    Weighted voting by expertise
  </Card>
</CardGroup>

---

## 4. Memory (Shared State)

Multiple approaches to shared memory across agents.

### Dedicated State Agent

```typescript
class StateAgent {
  private state: Map<string, any> = new Map();

  constructor() {
    this.client = new RelayClient({ agentName: 'StateStore' });
  }

  async start() {
    await this.client.connect();

    this.client.onMessage = (from, { body, data }) => {
      if (data?.action === 'get') {
        const value = this.state.get(data.key);
        this.client.sendMessage(from, JSON.stringify(value), 'state');
      } else if (data?.action === 'set') {
        this.state.set(data.key, JSON.parse(body));
        this.client.sendMessage(from, 'OK', 'state');
      }
    };
  }
}
```

### Channel-Based Shared Memory

```typescript
class SharedMemory {
  private cache: Map<string, any> = new Map();

  async init(client: RelayClient) {
    client.joinChannel('#memory');

    client.onChannelMessage = (from, channel, body) => {
      if (channel === '#memory') {
        const { key, value } = JSON.parse(body);
        this.cache.set(key, value);
      }
    };
  }

  set(client: RelayClient, key: string, value: any) {
    this.cache.set(key, value);
    client.sendChannelMessage('#memory', JSON.stringify({ key, value }));
  }

  get(key: string) {
    return this.cache.get(key);
  }
}
```

---

## 5. Discovery (Agent Registry)

Find and monitor available agents dynamically.

```typescript
// List all agents
const agents = await client.listAgents();

// Filter options
const active = await client.listAgents({ includeIdle: false });
const projectAgents = await client.listAgents({ project: 'myproject' });

// Agent info returned
interface AgentInfo {
  name: string;
  cli?: string;      // claude, codex, gemini
  idle?: boolean;
  parent?: string;   // spawner
  task?: string;
  connectedAt?: number;
}
```

### Discovery Patterns

```typescript
// Find specialist by task content
async function findSpecialist(specialty: string): Promise<string | null> {
  const agents = await client.listAgents({ includeIdle: false });

  for (const agent of agents) {
    if (agent.task?.toLowerCase().includes(specialty)) {
      return agent.name;
    }
  }
  return null;
}

// Load balancing - find least busy worker
async function leastBusyWorker(): Promise<string> {
  const metrics = await client.getMetrics();
  const workers = metrics.agents.filter(a => a.name.startsWith('Worker'));

  // Sort by CPU usage
  workers.sort((a, b) => (a.cpuPercent || 0) - (b.cpuPercent || 0));

  return workers[0]?.name || 'Worker-0';
}
```

---

## 6. Monitoring (Observability)

Built-in monitoring without external integrations.

```typescript
// System health
const health = await client.getHealth();
// { healthScore, issues, recommendations, crashes, alerts }

// Resource metrics
const metrics = await client.getMetrics();
// { agents: [...], system: { heapUsed, freeMemory } }

// Shadow monitoring (invisible observation)
client.bindAsShadow('TargetAgent', {
  receiveIncoming: true,
  receiveOutgoing: true,
});

// Agent logs
import { getLogs } from '@agent-relay/sdk';
const logs = await getLogs('Worker1', { lines: 100 });
```

### Auto-Scaling Pattern

```typescript
async function autoScale(minWorkers: number, maxWorkers: number) {
  const metrics = await client.getMetrics();
  const workers = metrics.agents.filter(a => a.name.startsWith('Worker'));
  const avgCpu = workers.reduce((sum, w) => sum + (w.cpuPercent || 0), 0) / workers.length;

  if (avgCpu > 80 && workers.length < maxWorkers) {
    await client.spawn({
      name: `Worker-${workers.length}`,
      cli: 'claude',
      task: 'General worker'
    });
  } else if (avgCpu < 20 && workers.length > minWorkers) {
    await client.release(workers[workers.length - 1].name);
  }
}
```

---

## Swarm Patterns

These primitives combine to enable common swarm patterns:

<CardGroup cols={2}>
  <Card title="Hierarchical" icon="sitemap" href="/guides/worker-orchestration">
    Lead coordinates specialist workers. Best for complex decomposable tasks.
  </Card>
  <Card title="Fan-Out/Fan-In" icon="arrows-split-up-and-left">
    Parallel execution with result aggregation. Best for embarrassingly parallel work.
  </Card>
  <Card title="Pipeline" icon="arrow-right-arrow-left">
    Sequential processing through agent stages. Best for multi-step workflows.
  </Card>
  <Card title="Self-Organizing" icon="users-gear">
    Agents discover each other and claim tasks. Best for dynamic workloads.
  </Card>
</CardGroup>

### Example: Full-Featured Swarm Coordinator

```typescript
class SwarmCoordinator {
  constructor(private client: RelayClient) {}

  // Handoff with continuity
  async delegateTask(target: string, task: string, context: any) {
    return this.client.sendAndWait(target, task, {
      data: { handoff: true, context },
    });
  }

  // Consensus for critical decisions
  async groupDecision(question: string, voters: string[]) {
    this.client.createProposal({
      title: question,
      participants: voters,
      consensusType: 'majority',
    });
  }

  // Memory via state channel
  async shareState(key: string, value: any) {
    this.client.sendChannelMessage('#swarm-state', JSON.stringify({ key, value }));
  }

  // Discovery for dynamic routing
  async findAvailableWorker(): Promise<string | null> {
    const agents = await this.client.listAgents({ includeIdle: true });
    const workers = agents.filter(a => a.name.startsWith('Worker') && a.idle);
    return workers[0]?.name || null;
  }

  // Monitoring via shadows
  async monitorWorker(name: string) {
    this.client.bindAsShadow(name, { receiveIncoming: true, receiveOutgoing: true });
  }
}
```

---

## Real-World Example: AgentSwarm

[AgentSwarm](https://github.com/AgentWorkforce/agentswarm) is a production multi-agent orchestrator built entirely on Agent Relay primitives:

```
Bootstrap → Conductor → Planner → Workers → Judge → Repeat
                ↓           ↓         ↓        ↓
           (spawn)    (sendMessage) (spawn) (consensus)
```

- **Conductor**: Deterministic orchestrator using `spawn()` and `sendMessage()`
- **Planner**: LLM agent that breaks down goals into tasks
- **Workers**: Parallel agents in isolated git worktrees
- **Judge**: Evaluates progress and decides next steps

Agent Relay handles all the communication, spawning, and coordination—you focus on the swarm logic.

## Summary

| Primitive | Capability |
|-----------|------------|
| `sendMessage()` | Handoffs, task delegation |
| `sendAndWait()` | Synchronous handoffs, checkpoints |
| `getInbox()` | Continuity, missed message recovery |
| Session resume | Continuity across disconnections |
| `createProposal()` / `vote()` | Consensus decisions |
| `sendChannelMessage()` | Shared memory, pub/sub |
| State payloads (`data`) | Context transfer, memory |
| `listAgents()` | Discovery, registry |
| `getMetrics()` / `getHealth()` | Monitoring, auto-scaling |
| `bindAsShadow()` | Invisible monitoring, QA |
| `spawn()` / `release()` | Dynamic team composition |

**Agent Relay gives you primitives. You build the swarm.**
